# Implementation Plan

This document outlines the steps for bringing the Tag Management System from specification to a running implementation.

## 1. Database Setup

**Objective:** Initialize and verify the PostgreSQL schema.

### 1.1. Start the Containers

Ensure all containers are running:

```bash
docker compose up -d
```

This starts:

* `tag-management-system_db` (PostgreSQL)
* `tag-management-system_pgadmin` (pgAdmin)
* `tag-management-system_dev` (development container)

Verify with:

```bash
docker ps
```

### 1.2. Register the Server in pgAdmin

Before creating or seeding the database, connect pgAdmin to the running PostgreSQL container.

1. Open pgAdmin in your browser at [http://localhost:5050](http://localhost:5050).
2. In the left sidebar, right-click **Servers → Register → Server…**
3. Configure the following:

	#### General Tab

	| Field    | Value                    |
	| -------- | ------------------------ |
	| **Name** | Tag Management System DB |

	#### Connection Tab

	| Field                    | Value         |
	| ------------------------ | ------------- |
	| **Host name/address**    | `postgres_db` |
	| **Port**                 | `5432`        |
	| **Maintenance database** | `app`         |
	| **Username**             | `app`         |
	| **Password**             | `app`         |

4. Click **Save**.

pgAdmin should now display a connection under *Servers → Tag Management System DB*. You can expand this to view the default database named `app`.

### 1.3. Create the Project Database

By default, the PostgreSQL container only creates one database (`app`). You can create a dedicated database for the Tag Management System.

#### Option A — via Docker CLI

```bash
docker exec -i tag-management-system_db psql -U app -c "CREATE DATABASE tag_management_system;"
```

#### Option B — via pgAdmin

1. Expand your registered server in pgAdmin.
2. Right-click **Databases → Create → Database…**
3. Set **Database name** to `tag_management_system`.
4. Leave **Owner** as `app` and click **Save**.

### 1.4. Troubleshooting Connections

If pgAdmin or `psql` fails to connect, review the following cases:

| Error Message                                                    | Likely Cause                                                         | Resolution                                                                                             |
| ---------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| `connection to server at "127.0.0.1" failed: Connection refused` | pgAdmin is trying to connect via localhost instead of Docker network | Ensure **Host name/address** is set to `postgres_db` (the service name)                                |
| `FATAL: database "tag_management_system" does not exist`         | Database hasn’t been created yet                                     | Run: `docker exec -i tag-management-system_db psql -U app -c "CREATE DATABASE tag_management_system;"` |
| `password authentication failed for user "app"`                  | Wrong username or password                                           | Use credentials from your compose file (`POSTGRES_USER=app`, `POSTGRES_PASSWORD=app`)                  |
| `timeout expired`                                                | Container not yet ready                                              | Wait a few seconds after `docker compose up -d` before connecting                                      |
| `could not connect to server: No route to host`                  | Containers not on the same network                                   | Ensure both `pgadmin` and `postgres_db` are attached to the `devnet` network                           |

Inspect logs for additional context:

```bash
docker logs tag-management-system_db
```

### 1.5. Verify Schema Integrity (optional)

After the schema is loaded (see Section 3), inspect tables:

```sql
\dt
\d+ table_name
```

## 2. FastAPI Database Connection

**Objective:** Connect the autogenerated FastAPI service to Postgres.

1. Create a `.env` file:

	```txt
	DATABASE_URL=postgresql+psycopg2://app:app@postgres_db:5432/tag_management_system
	```

2. Configure SQLAlchemy or your ORM to use `DATABASE_URL`.

3. Add a `/health/db` endpoint or startup event to verify database connectivity.

## 3. Seed and Validate Data

**Objective:** Populate initial records for testing.

Once the database containers are running and the `tag_management_system` database exists, you can initialize the schema and seed data directly from your local machine using the **pipe-in method**. This allows you to execute SQL files located on your host machine without copying them into the container.

### 3.1. Run Schema Initialization Script

Execute the following command to create all database tables, relationships, triggers, and constraints:

```bash
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/00_schema_init.sql
```

### 3.2. Run Seed Data Script

After the schema is initialized, populate the database with sample lookup and reference data:

```bash
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/01_seed_data.sql
```

### 3.3. Verify Schema and Data

After executing the scripts, verify that the tables and data were created correctly:

```bash
docker exec -it tag-management-system_db psql -U app -d tag_management_system
```

Once inside the PostgreSQL shell, run:

```sql
\dt
SELECT * FROM tags;
SELECT * FROM entities;
```

This confirms that the schema and seed data have been successfully loaded.

### 3.4. Database Reset Script (optional)

For iterative development and testing, you can quickly **drop and recreate the schema** to start from a clean state.

#### Option A — Reset Entire Database

This approach drops and recreates the `tag_management_system` database:

```bash
docker exec -i tag-management-system_db psql -U app -c "DROP DATABASE IF EXISTS tag_management_system;"
docker exec -i tag-management-system_db psql -U app -c "CREATE DATABASE tag_management_system;"
```

Then re-run your initialization scripts:

```bash
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/00_schema_init.sql
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/01_seed_data.sql
```

#### Option B — Drop All Tables (Keep Database)

You can also define a helper script (e.g., `scripts/02_reset_schema.sql`) with the following contents:

```sql
DO $$
DECLARE
  r RECORD;
BEGIN
  FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
    EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
  END LOOP;
END $$;
```

Run it using:

```bash
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/02_reset_schema.sql
```

Then reapply your schema and seed scripts as needed.

## 4. API Validation

**Objective:** Ensure FastAPI endpoints are functional and aligned with the OpenAPI specification.

1. Start the API:

	```bash
	uvicorn app.main:app --reload
	```

2. Verify the interactive documentation at `http://localhost:8000/docs`.

3. Test CRUD operations manually or using `curl`.

4. Compare `/openapi.json` output against `openapi.yaml`.

## 5. Testing and Schema Management

**Objective:** Prevent schema drift and verify endpoint behavior.

1. Implement `pytest` tests using `httpx.AsyncClient`.
2. Add migration management using **Alembic**.
3. Integrate schema validation tools to detect mismatches between ORM models and the database.

## 6. Containerization

**Objective:** Standardize environments through Docker Compose.

1. The `docker-compose.yml` defines the following services:

	* `postgres_db` — persistent PostgreSQL instance
	* `pgadmin` — database management UI
	* `dev` — development container for running scripts and API code

2. To start containers in the background:

	```bash
	docker compose up -d
	```

3. To stop them:

	```bash
	docker compose down
	```

4. Test connectivity from host:

	```bash
	curl http://localhost:8000/entities
	```

## 7. Logging and Observability

**Objective:** Enable consistent structured logging.

1. Integrate `structlog` or `loguru` for request-level logging.

	Capture:

	* Request start/stop
	* Exceptions and SQL errors
	* Audit metadata (`created_by`, `updated_by`)

2. Optionally add Prometheus or OpenTelemetry metrics.

## 8. CI/CD and Deployment

**Objective:** Automate testing and builds.

* Create GitHub Actions workflows for:

	* Linting and formatting
	* Running tests
	* Building and pushing Docker images
	* Prepare Terraform configurations for deploying to AWS or hybrid clusters.

## 9. Documentation Synchronization

**Objective:** Keep documentation and implementation aligned.

1. Commit finalized `openapi.yaml`.
2. Add `docs/api/implementation.md` describing the spec-to-code workflow.
3. Optionally generate static documentation:

	```bash
	npx redoc-cli bundle openapi.yaml -o docs/api.html
	```

## 10. Next Milestone

**Objective:** Integrate with the routing and event middleware.

Once the Tag Management System is verified locally, integrate it with the Routing & Scheduling Middleware.
This step will connect the Tag Management System to other microservices in the Data Management System ecosystem, such as the Image Processing System and Entity Management System.
