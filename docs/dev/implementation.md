# Implementation Plan

This document outlines the steps for bringing the Tag Management System from specification to a running implementation.

## 1. Database Setup

**Objective:** Initialize and verify the PostgreSQL schema.

### 1.1. Start the Containers

Ensure all containers are running:

```bash
docker compose up -d
```

This starts:

* `tag-management-system_db` (PostgreSQL)
* `tag-management-system_pgadmin` (pgAdmin)
* `tag-management-system_dev` (development container)

Verify with:

```bash
docker ps
```

### 1.2. Register the Server in pgAdmin

Before creating or seeding the database, connect pgAdmin to the running PostgreSQL container.

1. Open pgAdmin in your browser at [http://localhost:5050](http://localhost:5050).
2. In the left sidebar, right-click **Servers → Register → Server…**
3. Configure the following:

	#### General Tab

	| Field    | Value                    |
	| -------- | ------------------------ |
	| **Name** | Tag Management System DB |

	#### Connection Tab

	| Field                    | Value         |
	| ------------------------ | ------------- |
	| **Host name/address**    | `postgres_db` |
	| **Port**                 | `5432`        |
	| **Maintenance database** | `app`         |
	| **Username**             | `app`         |
	| **Password**             | `app`         |

4. Click **Save**.

pgAdmin should now display a connection under *Servers → Tag Management System DB*. You can expand this to view the default database named `app`.

### 1.3. Create the Project Database

By default, the PostgreSQL container only creates one database (`app`). You can create a dedicated database for the Tag Management System.

#### Option A — via Docker CLI

```bash
docker exec -i tag-management-system_db psql -U app -c "CREATE DATABASE tag_management_system;"
```

#### Option B — via pgAdmin

1. Expand your registered server in pgAdmin.
2. Right-click **Databases → Create → Database…**
3. Set **Database name** to `tag_management_system`.
4. Leave **Owner** as `app` and click **Save**.

### 1.4. Troubleshooting Connections

If pgAdmin or `psql` fails to connect, review the following cases:

| Error Message                                                    | Likely Cause                                                         | Resolution                                                                                             |
| ---------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| `connection to server at "127.0.0.1" failed: Connection refused` | pgAdmin is trying to connect via localhost instead of Docker network | Ensure **Host name/address** is set to `postgres_db` (the service name)                                |
| `FATAL: database "tag_management_system" does not exist`         | Database hasn’t been created yet                                     | Run: `docker exec -i tag-management-system_db psql -U app -c "CREATE DATABASE tag_management_system;"` |
| `password authentication failed for user "app"`                  | Wrong username or password                                           | Use credentials from your compose file (`POSTGRES_USER=app`, `POSTGRES_PASSWORD=app`)                  |
| `timeout expired`                                                | Container not yet ready                                              | Wait a few seconds after `docker compose up -d` before connecting                                      |
| `could not connect to server: No route to host`                  | Containers not on the same network                                   | Ensure both `pgadmin` and `postgres_db` are attached to the `devnet` network                           |

Inspect container logs for additional context:

```bash
docker logs tag-management-system_db
```

To initialize a fully working local environment from scratch:

```bash
docker compose up -d
docker exec -i tag-management-system_db psql -U app -c "CREATE DATABASE tag_management_system;"
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/00_schema_init.sql
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/01_seed_data.sql
```

Verify schema and data:

```bash
docker exec -it tag-management-system_db psql -U app -d tag_management_system
\dt
SELECT * FROM tags;
```

This provides a reproducible baseline for any developer or CI environment.

After the schema is loaded (see Section 3), inspect tables:

```sql
\dt
\d+ table_name
```

**Objective:** Connect the autogenerated FastAPI service to Postgres.

1. Create a `.env` file:

	```txt
	DATABASE_URL=postgresql+psycopg2://app:app@postgres_db:5432/tag_management_system
	```

2. Configure SQLAlchemy or your ORM to use `DATABASE_URL`.
3. Add a `/health/db` endpoint or startup event to verify database connectivity.

**Objective:** Populate initial records for testing.

Once the database containers are running and the `tag_management_system` database exists, you can initialize the schema and seed data directly from your local machine using the pipe-in method. This allows you to execute SQL files located on your host machine without copying them into the container.

### 3.1. Run Schema Initialization Script

```bash
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/00_schema_init.sql
```

### 3.2. Run Seed Data Script

```bash
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/01_seed_data.sql
```

### 3.3. Verify Schema and Data

```bash
docker exec -it tag-management-system_db psql -U app -d tag_management_system
```

Once inside the PostgreSQL shell, run:

```sql
\dt
SELECT * FROM tags;
SELECT * FROM entities;
```

For iterative development and testing, you can quickly drop and recreate the schema.

#### Reset Entire Database

```bash
docker exec -i tag-management-system_db psql -U app -c "DROP DATABASE IF EXISTS tag_management_system;"
docker exec -i tag-management-system_db psql -U app -c "CREATE DATABASE tag_management_system;"
```

Re-run schema and seed scripts:

```bash
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/00_schema_init.sql
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/01_seed_data.sql
```

**Drop All Tables (Keep Database)**

```sql
DO $$
DECLARE
  r RECORD;
BEGIN
  FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
    EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
  END LOOP;
END $$;
```

Save this as `scripts/02_reset_schema.sql` and run:

```bash
docker exec -i tag-management-system_db psql -U app -d tag_management_system < scripts/02_reset_schema.sql
```

**Objective:** Ensure FastAPI endpoints are functional and aligned with the OpenAPI specification.

1. Start the API:

	```bash
	uvicorn app.main:app --reload
	```

2. Verify documentation at [http://localhost:8000/docs](http://localhost:8000/docs)
3. Test CRUD operations manually or using `curl`.
4. Compare `/openapi.json` output against `openapi.yaml`.

**Objective:** Prevent schema drift and support controlled database evolution.

1. Implement `pytest` tests using `httpx.AsyncClient` for endpoint verification.
2. Add Alembic for schema migration management.
3. Use schema validation utilities to detect mismatches between ORM models and the database.

### 5.1. Schema Migration Strategy

**Objective:** Transition from manual SQL execution to automated versioned migrations.**

Once the schema stabilizes, database changes should be handled through Alembic, SQLAlchemy’s migration tool. This ensures all environments evolve in a controlled, versioned manner.

#### Initialize Alembic

```bash
alembic init migrations
```

This creates:

* `env.py` — runtime configuration
* `script.py.mako` — migration template
* `versions/` — versioned migration files

#### Configure Alembic

In `alembic.ini`, update:

```txt
sqlalchemy.url = postgresql+psycopg2://app:app@postgres_db:5432/tag_management_system
```

Or, load from `.env` in `env.py`:

```py
from dotenv import load_dotenv
import os

load_dotenv()
config.set_main_option("sqlalchemy.url", os.getenv("DATABASE_URL"))
```

#### Generate and Apply Migrations

Autogenerate migration when models change:

```bash
alembic revision --autogenerate -m "Add new column or table"
```

Apply migrations:

```bash
alembic upgrade head
```

Revert the most recent migration:

```bash
alembic downgrade -1
```

#### Integrate with CI/CD

* Add `alembic upgrade head` to deployment workflows.
* Commit all migration files under `migrations/versions/`.
* Test locally before promoting to production.

**Objective:** Ensure safe experimentation and reliable rollback during migration failures or data loss.**

#### Backups Before Destructive Changes

```bash
docker exec -i tag-management-system_db pg_dump -U app tag_management_system > backups/backup_$(date +%Y%m%d_%H%M).sql
```

Restore backup:

```bash
cat backups/backup_<timestamp>.sql | docker exec -i tag-management-system_db psql -U app -d tag_management_system
```

#### Test Migrations in Isolation

```bash
docker exec -i tag-management-system_db psql -U app -c "CREATE DATABASE tag_management_system_test TEMPLATE tag_management_system;"
# run Alembic migrations on the test database
docker exec -i tag-management-system_db psql -U app -c "DROP DATABASE tag_management_system_test;"
```

#### Safe Rollback Pattern

1. Roll back schema:

   ```bash
   alembic downgrade -1
   ```

2. Restore data if needed:

   ```bash
   cat backups/backup_<timestamp>.sql | docker exec -i tag-management-system_db psql -U app -d tag_management_system
   ```

3. Fix migration and reapply:

	```bash
	alembic upgrade head
	```

**Objective:** Standardize environments through Docker Compose.

1. The `docker-compose.yml` defines:

	* `postgres_db` — persistent PostgreSQL instance
	* `pgadmin` — database management UI
	* `dev` — development container for running scripts and API code

2. Start containers:

	```bash
	docker compose up -d
	```

3. Stop containers:

	```bash
	docker compose down
	```

4. Test connectivity:

	```bash
	curl http://localhost:8000/entities
	```

**Objective:** Enable consistent structured logging.

1. Integrate `structlog` or `loguru` for request-level logging.
2. Capture:

	* Request start/stop
	* Exceptions and SQL errors
	* Audit metadata (`created_by`, `updated_by`)

3. Optionally add Prometheus or OpenTelemetry metrics.

**Objective:** Automate testing and builds.

* Create GitHub Actions workflows for:

	* Linting and formatting
	* Running tests
	* Building and pushing Docker images
	* Add `alembic upgrade head` to deployment steps
	* Prepare Terraform configurations for AWS or hybrid clusters.

**Objective:** Keep documentation and implementation aligned.

1. Commit finalized `openapi.yaml`.
2. Add `docs/api/implementation.md` to describe spec-to-code workflow.
3. Optionally generate static documentation:

	```bash
	npx redoc-cli bundle openapi.yaml -o docs/api.html
	```

**Objective:** Integrate with the routing and event middleware.

Once the Tag Management System is verified locally, integrate it with the Routing & Scheduling Middleware.
This connects it to other microservices in the Data Management System ecosystem, such as the Image Processing System and Entity Management System.
